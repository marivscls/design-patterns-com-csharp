Design Patterns com C#
Este repositório contém exemplos práticos e exercícios baseados no livro "Design Patterns", implementados em C#. O objetivo é fornecer uma referência clara e prática para desenvolvedores que desejam aprofundar seus conhecimentos em padrões de design e aplicá-los em projetos reais.

Conteúdo
Exemplos de Código
Padrão Singleton: Garantir que uma classe tenha apenas uma instância e fornecer um ponto global de acesso a ela.
Padrão Factory Method: Definir uma interface para criar um objeto, mas deixar as subclasses decidirem qual classe instanciar.
Padrão Abstract Factory: Fornecer uma interface para criar famílias de objetos relacionados ou dependentes sem especificar suas classes concretas.
Padrão Builder: Separar a construção de um objeto complexo da sua representação, permitindo que o mesmo processo de construção possa criar diferentes representações.
Padrão Prototype: Especificar os tipos de objetos a serem criados usando uma instância prototípica e criar novos objetos copiando este protótipo.
Padrão Adapter: Permitir que a interface de uma classe existente seja usada como outra interface.
Padrão Bridge: Desacoplar uma abstração da sua implementação para que as duas possam variar independentemente.
Padrão Composite: Compor objetos em estruturas de árvore para representar hierarquias partes-todo.
Padrão Decorator: Anexar responsabilidades adicionais a um objeto dinamicamente.
Padrão Facade: Fornecer uma interface simplificada para um conjunto de interfaces em um subsistema.
Padrão Flyweight: Usar compartilhamento para suportar eficientemente grandes quantidades de objetos de granularidade fina.
Padrão Proxy: Fornecer um substituto ou marcador para outro objeto para controlar o acesso a ele.
Padrão Chain of Responsibility: Evitar acoplamento do remetente de uma solicitação ao seu receptor, dando a mais de um objeto a chance de tratar a solicitação.
Padrão Command: Encapsular uma solicitação como um objeto, permitindo parametrizar clientes com diferentes solicitações.
Padrão Interpreter: Dada uma linguagem, definir uma representação para sua gramática e um interpretador que usa a representação para interpretar sentenças na linguagem.
Padrão Iterator: Fornecer um modo de acessar sequencialmente os elementos de um agregado sem expor sua representação subjacente.
Padrão Mediator: Definir um objeto que encapsula a forma como um conjunto de objetos interage.
Padrão Memento: Sem violar o encapsulamento, capturar e externalizar um estado interno de um objeto, de modo que o objeto possa ser restaurado a esse estado mais tarde.
Padrão Observer: Definir uma dependência um-para-muitos entre objetos, de modo que quando um objeto muda de estado, todos os seus dependentes são notificados e atualizados automaticamente.
Padrão State: Permitir que um objeto altere seu comportamento quando seu estado interno muda.
Padrão Strategy: Definir uma família de algoritmos, encapsular cada um deles e torná-los intercambiáveis.
Padrão Template Method: Definir o esqueleto de um algoritmo em uma operação, postergando a definição de alguns passos para subclasses.
Padrão Visitor: Representar uma operação a ser executada nos elementos de uma estrutura de objeto.
Práticas e Exercícios
Além dos exemplos de código, cada diretório de padrão inclui exercícios e desafios para praticar e reforçar o entendimento dos conceitos.

Anotações e Resumos
Resumos dos capítulos do livro "Design Patterns" e anotações detalhadas sobre os principais conceitos e implementações.

Objetivo
Este repositório foi criado para servir como um recurso de estudo e referência para desenvolvedores que desejam:

Melhorar a qualidade e a manutenibilidade do código.
Aprofundar seus conhecimentos em padrões de design.
Aplicar os padrões em projetos reais.

Contribuições
Contribuições são bem-vindas! Sinta-se à vontade para abrir issues e pull requests com sugestões, correções ou novos exemplos.

